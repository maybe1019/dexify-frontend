/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface FundDeployerInterface extends utils.Interface {
  functions: {
    'cancelMigration(address)': FunctionFragment;
    'cancelMigrationEmergency(address)': FunctionFragment;
    'createMigratedFundConfig(address,uint256,bytes,bytes)': FunctionFragment;
    'createNewFund(address,string,address,uint256,bytes,bytes)': FunctionFragment;
    'deregisterVaultCalls(address[],bytes4[])': FunctionFragment;
    'executeMigration(address)': FunctionFragment;
    'executeMigrationEmergency(address)': FunctionFragment;
    'getComptrollerLib()': FunctionFragment;
    'getCreator()': FunctionFragment;
    'getDispatcher()': FunctionFragment;
    'getOwner()': FunctionFragment;
    'getPendingComptrollerProxyCreator(address)': FunctionFragment;
    'getReleaseStatus()': FunctionFragment;
    'getVaultLib()': FunctionFragment;
    'invokeMigrationInCancelHook(address,address,address,address)': FunctionFragment;
    'invokeMigrationOutHook(uint8,address,address,address,address)': FunctionFragment;
    'isRegisteredVaultCall(address,bytes4)': FunctionFragment;
    'registerVaultCalls(address[],bytes4[])': FunctionFragment;
    'setComptrollerLib(address)': FunctionFragment;
    'setReleaseStatus(uint8)': FunctionFragment;
    'signalMigration(address,address)': FunctionFragment;
    'signalMigrationEmergency(address,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'cancelMigration'
      | 'cancelMigrationEmergency'
      | 'createMigratedFundConfig'
      | 'createNewFund'
      | 'deregisterVaultCalls'
      | 'executeMigration'
      | 'executeMigrationEmergency'
      | 'getComptrollerLib'
      | 'getCreator'
      | 'getDispatcher'
      | 'getOwner'
      | 'getPendingComptrollerProxyCreator'
      | 'getReleaseStatus'
      | 'getVaultLib'
      | 'invokeMigrationInCancelHook'
      | 'invokeMigrationOutHook'
      | 'isRegisteredVaultCall'
      | 'registerVaultCalls'
      | 'setComptrollerLib'
      | 'setReleaseStatus'
      | 'signalMigration'
      | 'signalMigrationEmergency',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'cancelMigration',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'cancelMigrationEmergency',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'createMigratedFundConfig',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'createNewFund',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'deregisterVaultCalls',
    values: [PromiseOrValue<string>[], PromiseOrValue<BytesLike>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'executeMigration',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'executeMigrationEmergency',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getComptrollerLib',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getCreator',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getDispatcher',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'getOwner', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getPendingComptrollerProxyCreator',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getReleaseStatus',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getVaultLib',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'invokeMigrationInCancelHook',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'invokeMigrationOutHook',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'isRegisteredVaultCall',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'registerVaultCalls',
    values: [PromiseOrValue<string>[], PromiseOrValue<BytesLike>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'setComptrollerLib',
    values: [PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setReleaseStatus',
    values: [PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'signalMigration',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'signalMigrationEmergency',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(
    functionFragment: 'cancelMigration',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'cancelMigrationEmergency',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'createMigratedFundConfig',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'createNewFund',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'deregisterVaultCalls',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'executeMigration',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'executeMigrationEmergency',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getComptrollerLib',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'getCreator', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getDispatcher',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'getOwner', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getPendingComptrollerProxyCreator',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getReleaseStatus',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getVaultLib',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'invokeMigrationInCancelHook',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'invokeMigrationOutHook',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isRegisteredVaultCall',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'registerVaultCalls',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setComptrollerLib',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setReleaseStatus',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'signalMigration',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'signalMigrationEmergency',
    data: BytesLike,
  ): Result;

  events: {
    'ComptrollerLibSet(address)': EventFragment;
    'ComptrollerProxyDeployed(address,address,address,uint256,bytes,bytes,bool)': EventFragment;
    'NewFundCreated(address,address,address,address,string,address,uint256,bytes,bytes)': EventFragment;
    'ReleaseStatusSet(uint8,uint8)': EventFragment;
    'VaultCallDeregistered(address,bytes4)': EventFragment;
    'VaultCallRegistered(address,bytes4)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ComptrollerLibSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ComptrollerProxyDeployed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'NewFundCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ReleaseStatusSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultCallDeregistered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultCallRegistered'): EventFragment;
}

export interface ComptrollerLibSetEventObject {
  comptrollerLib: string;
}
export type ComptrollerLibSetEvent = TypedEvent<
  [string],
  ComptrollerLibSetEventObject
>;

export type ComptrollerLibSetEventFilter =
  TypedEventFilter<ComptrollerLibSetEvent>;

export interface ComptrollerProxyDeployedEventObject {
  creator: string;
  comptrollerProxy: string;
  denominationAsset: string;
  sharesActionTimelock: BigNumber;
  feeManagerConfigData: string;
  policyManagerConfigData: string;
  forMigration: boolean;
}
export type ComptrollerProxyDeployedEvent = TypedEvent<
  [string, string, string, BigNumber, string, string, boolean],
  ComptrollerProxyDeployedEventObject
>;

export type ComptrollerProxyDeployedEventFilter =
  TypedEventFilter<ComptrollerProxyDeployedEvent>;

export interface NewFundCreatedEventObject {
  creator: string;
  comptrollerProxy: string;
  vaultProxy: string;
  fundOwner: string;
  fundName: string;
  denominationAsset: string;
  sharesActionTimelock: BigNumber;
  feeManagerConfigData: string;
  policyManagerConfigData: string;
}
export type NewFundCreatedEvent = TypedEvent<
  [string, string, string, string, string, string, BigNumber, string, string],
  NewFundCreatedEventObject
>;

export type NewFundCreatedEventFilter = TypedEventFilter<NewFundCreatedEvent>;

export interface ReleaseStatusSetEventObject {
  prevStatus: number;
  nextStatus: number;
}
export type ReleaseStatusSetEvent = TypedEvent<
  [number, number],
  ReleaseStatusSetEventObject
>;

export type ReleaseStatusSetEventFilter =
  TypedEventFilter<ReleaseStatusSetEvent>;

export interface VaultCallDeregisteredEventObject {
  contractAddress: string;
  selector: string;
}
export type VaultCallDeregisteredEvent = TypedEvent<
  [string, string],
  VaultCallDeregisteredEventObject
>;

export type VaultCallDeregisteredEventFilter =
  TypedEventFilter<VaultCallDeregisteredEvent>;

export interface VaultCallRegisteredEventObject {
  contractAddress: string;
  selector: string;
}
export type VaultCallRegisteredEvent = TypedEvent<
  [string, string],
  VaultCallRegisteredEventObject
>;

export type VaultCallRegisteredEventFilter =
  TypedEventFilter<VaultCallRegisteredEvent>;

export interface FundDeployer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FundDeployerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>,
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Cancels fund migration
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Cancels fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Creates a fully-configured ComptrollerProxy, to which a fund from a previous release can migrate in a subsequent step
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createMigratedFundConfig(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Creates a new fund
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _fundName The name of the fund
     * @param _fundOwner The address of the owner for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createNewFund(
      _fundOwner: PromiseOrValue<string>,
      _fundName: PromiseOrValue<string>,
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * De-registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to de-register
     * @param _selectors The selectors of the calls to de-register
     */
    deregisterVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Executes fund migration
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Executes fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Gets the `comptrollerLib` variable value
     */
    getComptrollerLib(
      overrides?: CallOverrides,
    ): Promise<[string] & { comptrollerLib_: string }>;

    /**
     * Gets the `CREATOR` variable value
     */
    getCreator(
      overrides?: CallOverrides,
    ): Promise<[string] & { creator_: string }>;

    /**
     * Gets the `DISPATCHER` variable value
     */
    getDispatcher(
      overrides?: CallOverrides,
    ): Promise<[string] & { dispatcher_: string }>;

    /**
     * Dynamically gets the owner based on the Protocol status. The owner is initially the contract's deployer, for convenience in setting up configuration. Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council) sets the releaseStatus to `Live`.
     * Gets the current owner of the contract
     */
    getOwner(overrides?: CallOverrides): Promise<[string] & { owner_: string }>;

    /**
     * Gets the creator of a pending ComptrollerProxy
     */
    getPendingComptrollerProxyCreator(
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[string] & { pendingComptrollerProxyCreator_: string }>;

    /**
     * Gets the `releaseStatus` variable value
     */
    getReleaseStatus(
      overrides?: CallOverrides,
    ): Promise<[number] & { status_: number }>;

    /**
     * Gets the `VAULT_LIB` variable value
     */
    getVaultLib(
      overrides?: CallOverrides,
    ): Promise<[string] & { vaultLib_: string }>;

    /**
     * Unimplemented
     */
    invokeMigrationInCancelHook(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Allows "hooking into" specific moments in the migration pipeline to execute arbitrary logic during a migration out of this release
     * @param _vaultProxy The VaultProxy being migrated
     */
    invokeMigrationOutHook(
      _hook: PromiseOrValue<BigNumberish>,
      _vaultProxy: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      arg4: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Checks if a contract call is registered
     * @param _contract The contract of the call to check
     * @param _selector The selector of the call to check
     */
    isRegisteredVaultCall(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { isRegistered_: boolean }>;

    /**
     * Registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to register
     * @param _selectors The selectors of the calls to register
     */
    registerVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Can only be set once
     * Sets the comptrollerLib
     * @param _comptrollerLib The ComptrollerLib contract address
     */
    setComptrollerLib(
      _comptrollerLib: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Sets the status of the protocol to a new state
     * @param _nextStatus The next status state to set
     */
    setReleaseStatus(
      _nextStatus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Signal a fund migration
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigration(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Signal a fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  /**
   * Cancels fund migration
   * @param _vaultProxy The VaultProxy for which to cancel migration
   */
  cancelMigration(
    _vaultProxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Cancels fund migration, bypassing any failures. Should be used in an emergency only.
   * @param _vaultProxy The VaultProxy for which to cancel migration
   */
  cancelMigrationEmergency(
    _vaultProxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Creates a fully-configured ComptrollerProxy, to which a fund from a previous release can migrate in a subsequent step
   * @param _denominationAsset The contract address of the denomination asset for the fund
   * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
   * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
   * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
   */
  createMigratedFundConfig(
    _denominationAsset: PromiseOrValue<string>,
    _sharesActionTimelock: PromiseOrValue<BigNumberish>,
    _feeManagerConfigData: PromiseOrValue<BytesLike>,
    _policyManagerConfigData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Creates a new fund
   * @param _denominationAsset The contract address of the denomination asset for the fund
   * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
   * @param _fundName The name of the fund
   * @param _fundOwner The address of the owner for the fund
   * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
   * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
   */
  createNewFund(
    _fundOwner: PromiseOrValue<string>,
    _fundName: PromiseOrValue<string>,
    _denominationAsset: PromiseOrValue<string>,
    _sharesActionTimelock: PromiseOrValue<BigNumberish>,
    _feeManagerConfigData: PromiseOrValue<BytesLike>,
    _policyManagerConfigData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * De-registers allowed arbitrary contract calls that can be sent from the VaultProxy
   * @param _contracts The contracts of the calls to de-register
   * @param _selectors The selectors of the calls to de-register
   */
  deregisterVaultCalls(
    _contracts: PromiseOrValue<string>[],
    _selectors: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Executes fund migration
   * @param _vaultProxy The VaultProxy for which to execute the migration
   */
  executeMigration(
    _vaultProxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Executes fund migration, bypassing any failures. Should be used in an emergency only.
   * @param _vaultProxy The VaultProxy for which to execute the migration
   */
  executeMigrationEmergency(
    _vaultProxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Gets the `comptrollerLib` variable value
   */
  getComptrollerLib(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `CREATOR` variable value
   */
  getCreator(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `DISPATCHER` variable value
   */
  getDispatcher(overrides?: CallOverrides): Promise<string>;

  /**
   * Dynamically gets the owner based on the Protocol status. The owner is initially the contract's deployer, for convenience in setting up configuration. Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council) sets the releaseStatus to `Live`.
   * Gets the current owner of the contract
   */
  getOwner(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the creator of a pending ComptrollerProxy
   */
  getPendingComptrollerProxyCreator(
    _comptrollerProxy: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<string>;

  /**
   * Gets the `releaseStatus` variable value
   */
  getReleaseStatus(overrides?: CallOverrides): Promise<number>;

  /**
   * Gets the `VAULT_LIB` variable value
   */
  getVaultLib(overrides?: CallOverrides): Promise<string>;

  /**
   * Unimplemented
   */
  invokeMigrationInCancelHook(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<string>,
    arg3: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Allows "hooking into" specific moments in the migration pipeline to execute arbitrary logic during a migration out of this release
   * @param _vaultProxy The VaultProxy being migrated
   */
  invokeMigrationOutHook(
    _hook: PromiseOrValue<BigNumberish>,
    _vaultProxy: PromiseOrValue<string>,
    arg2: PromiseOrValue<string>,
    arg3: PromiseOrValue<string>,
    arg4: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Checks if a contract call is registered
   * @param _contract The contract of the call to check
   * @param _selector The selector of the call to check
   */
  isRegisteredVaultCall(
    _contract: PromiseOrValue<string>,
    _selector: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  /**
   * Registers allowed arbitrary contract calls that can be sent from the VaultProxy
   * @param _contracts The contracts of the calls to register
   * @param _selectors The selectors of the calls to register
   */
  registerVaultCalls(
    _contracts: PromiseOrValue<string>[],
    _selectors: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Can only be set once
   * Sets the comptrollerLib
   * @param _comptrollerLib The ComptrollerLib contract address
   */
  setComptrollerLib(
    _comptrollerLib: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Sets the status of the protocol to a new state
   * @param _nextStatus The next status state to set
   */
  setReleaseStatus(
    _nextStatus: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Signal a fund migration
   * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
   * @param _vaultProxy The VaultProxy for which to signal the migration
   */
  signalMigration(
    _vaultProxy: PromiseOrValue<string>,
    _comptrollerProxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Signal a fund migration, bypassing any failures. Should be used in an emergency only.
   * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
   * @param _vaultProxy The VaultProxy for which to signal the migration
   */
  signalMigrationEmergency(
    _vaultProxy: PromiseOrValue<string>,
    _comptrollerProxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Cancels fund migration
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Cancels fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Creates a fully-configured ComptrollerProxy, to which a fund from a previous release can migrate in a subsequent step
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createMigratedFundConfig(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    /**
     * Creates a new fund
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _fundName The name of the fund
     * @param _fundOwner The address of the owner for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createNewFund(
      _fundOwner: PromiseOrValue<string>,
      _fundName: PromiseOrValue<string>,
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<
      [string, string] & { comptrollerProxy_: string; vaultProxy_: string }
    >;

    /**
     * De-registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to de-register
     * @param _selectors The selectors of the calls to de-register
     */
    deregisterVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Executes fund migration
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Executes fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Gets the `comptrollerLib` variable value
     */
    getComptrollerLib(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `CREATOR` variable value
     */
    getCreator(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `DISPATCHER` variable value
     */
    getDispatcher(overrides?: CallOverrides): Promise<string>;

    /**
     * Dynamically gets the owner based on the Protocol status. The owner is initially the contract's deployer, for convenience in setting up configuration. Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council) sets the releaseStatus to `Live`.
     * Gets the current owner of the contract
     */
    getOwner(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the creator of a pending ComptrollerProxy
     */
    getPendingComptrollerProxyCreator(
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<string>;

    /**
     * Gets the `releaseStatus` variable value
     */
    getReleaseStatus(overrides?: CallOverrides): Promise<number>;

    /**
     * Gets the `VAULT_LIB` variable value
     */
    getVaultLib(overrides?: CallOverrides): Promise<string>;

    /**
     * Unimplemented
     */
    invokeMigrationInCancelHook(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Allows "hooking into" specific moments in the migration pipeline to execute arbitrary logic during a migration out of this release
     * @param _vaultProxy The VaultProxy being migrated
     */
    invokeMigrationOutHook(
      _hook: PromiseOrValue<BigNumberish>,
      _vaultProxy: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      arg4: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Checks if a contract call is registered
     * @param _contract The contract of the call to check
     * @param _selector The selector of the call to check
     */
    isRegisteredVaultCall(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    /**
     * Registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to register
     * @param _selectors The selectors of the calls to register
     */
    registerVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Can only be set once
     * Sets the comptrollerLib
     * @param _comptrollerLib The ComptrollerLib contract address
     */
    setComptrollerLib(
      _comptrollerLib: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Sets the status of the protocol to a new state
     * @param _nextStatus The next status state to set
     */
    setReleaseStatus(
      _nextStatus: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Signal a fund migration
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigration(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Signal a fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'ComptrollerLibSet(address)'(
      comptrollerLib?: null,
    ): ComptrollerLibSetEventFilter;
    ComptrollerLibSet(comptrollerLib?: null): ComptrollerLibSetEventFilter;

    'ComptrollerProxyDeployed(address,address,address,uint256,bytes,bytes,bool)'(
      creator?: PromiseOrValue<string> | null,
      comptrollerProxy?: null,
      denominationAsset?: PromiseOrValue<string> | null,
      sharesActionTimelock?: null,
      feeManagerConfigData?: null,
      policyManagerConfigData?: null,
      forMigration?: PromiseOrValue<boolean> | null,
    ): ComptrollerProxyDeployedEventFilter;
    ComptrollerProxyDeployed(
      creator?: PromiseOrValue<string> | null,
      comptrollerProxy?: null,
      denominationAsset?: PromiseOrValue<string> | null,
      sharesActionTimelock?: null,
      feeManagerConfigData?: null,
      policyManagerConfigData?: null,
      forMigration?: PromiseOrValue<boolean> | null,
    ): ComptrollerProxyDeployedEventFilter;

    'NewFundCreated(address,address,address,address,string,address,uint256,bytes,bytes)'(
      creator?: PromiseOrValue<string> | null,
      comptrollerProxy?: null,
      vaultProxy?: null,
      fundOwner?: PromiseOrValue<string> | null,
      fundName?: null,
      denominationAsset?: PromiseOrValue<string> | null,
      sharesActionTimelock?: null,
      feeManagerConfigData?: null,
      policyManagerConfigData?: null,
    ): NewFundCreatedEventFilter;
    NewFundCreated(
      creator?: PromiseOrValue<string> | null,
      comptrollerProxy?: null,
      vaultProxy?: null,
      fundOwner?: PromiseOrValue<string> | null,
      fundName?: null,
      denominationAsset?: PromiseOrValue<string> | null,
      sharesActionTimelock?: null,
      feeManagerConfigData?: null,
      policyManagerConfigData?: null,
    ): NewFundCreatedEventFilter;

    'ReleaseStatusSet(uint8,uint8)'(
      prevStatus?: PromiseOrValue<BigNumberish> | null,
      nextStatus?: PromiseOrValue<BigNumberish> | null,
    ): ReleaseStatusSetEventFilter;
    ReleaseStatusSet(
      prevStatus?: PromiseOrValue<BigNumberish> | null,
      nextStatus?: PromiseOrValue<BigNumberish> | null,
    ): ReleaseStatusSetEventFilter;

    'VaultCallDeregistered(address,bytes4)'(
      contractAddress?: PromiseOrValue<string> | null,
      selector?: null,
    ): VaultCallDeregisteredEventFilter;
    VaultCallDeregistered(
      contractAddress?: PromiseOrValue<string> | null,
      selector?: null,
    ): VaultCallDeregisteredEventFilter;

    'VaultCallRegistered(address,bytes4)'(
      contractAddress?: PromiseOrValue<string> | null,
      selector?: null,
    ): VaultCallRegisteredEventFilter;
    VaultCallRegistered(
      contractAddress?: PromiseOrValue<string> | null,
      selector?: null,
    ): VaultCallRegisteredEventFilter;
  };

  estimateGas: {
    /**
     * Cancels fund migration
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Cancels fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Creates a fully-configured ComptrollerProxy, to which a fund from a previous release can migrate in a subsequent step
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createMigratedFundConfig(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Creates a new fund
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _fundName The name of the fund
     * @param _fundOwner The address of the owner for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createNewFund(
      _fundOwner: PromiseOrValue<string>,
      _fundName: PromiseOrValue<string>,
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * De-registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to de-register
     * @param _selectors The selectors of the calls to de-register
     */
    deregisterVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Executes fund migration
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Executes fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Gets the `comptrollerLib` variable value
     */
    getComptrollerLib(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `CREATOR` variable value
     */
    getCreator(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `DISPATCHER` variable value
     */
    getDispatcher(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Dynamically gets the owner based on the Protocol status. The owner is initially the contract's deployer, for convenience in setting up configuration. Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council) sets the releaseStatus to `Live`.
     * Gets the current owner of the contract
     */
    getOwner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the creator of a pending ComptrollerProxy
     */
    getPendingComptrollerProxyCreator(
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Gets the `releaseStatus` variable value
     */
    getReleaseStatus(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `VAULT_LIB` variable value
     */
    getVaultLib(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Unimplemented
     */
    invokeMigrationInCancelHook(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Allows "hooking into" specific moments in the migration pipeline to execute arbitrary logic during a migration out of this release
     * @param _vaultProxy The VaultProxy being migrated
     */
    invokeMigrationOutHook(
      _hook: PromiseOrValue<BigNumberish>,
      _vaultProxy: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      arg4: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Checks if a contract call is registered
     * @param _contract The contract of the call to check
     * @param _selector The selector of the call to check
     */
    isRegisteredVaultCall(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to register
     * @param _selectors The selectors of the calls to register
     */
    registerVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Can only be set once
     * Sets the comptrollerLib
     * @param _comptrollerLib The ComptrollerLib contract address
     */
    setComptrollerLib(
      _comptrollerLib: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Sets the status of the protocol to a new state
     * @param _nextStatus The next status state to set
     */
    setReleaseStatus(
      _nextStatus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Signal a fund migration
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigration(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Signal a fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Cancels fund migration
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Cancels fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to cancel migration
     */
    cancelMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a fully-configured ComptrollerProxy, to which a fund from a previous release can migrate in a subsequent step
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createMigratedFundConfig(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Creates a new fund
     * @param _denominationAsset The contract address of the denomination asset for the fund
     * @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund
     * @param _fundName The name of the fund
     * @param _fundOwner The address of the owner for the fund
     * @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    createNewFund(
      _fundOwner: PromiseOrValue<string>,
      _fundName: PromiseOrValue<string>,
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * De-registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to de-register
     * @param _selectors The selectors of the calls to de-register
     */
    deregisterVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Executes fund migration
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigration(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Executes fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _vaultProxy The VaultProxy for which to execute the migration
     */
    executeMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `comptrollerLib` variable value
     */
    getComptrollerLib(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the `CREATOR` variable value
     */
    getCreator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the `DISPATCHER` variable value
     */
    getDispatcher(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Dynamically gets the owner based on the Protocol status. The owner is initially the contract's deployer, for convenience in setting up configuration. Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council) sets the releaseStatus to `Live`.
     * Gets the current owner of the contract
     */
    getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the creator of a pending ComptrollerProxy
     */
    getPendingComptrollerProxyCreator(
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `releaseStatus` variable value
     */
    getReleaseStatus(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the `VAULT_LIB` variable value
     */
    getVaultLib(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Unimplemented
     */
    invokeMigrationInCancelHook(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Allows "hooking into" specific moments in the migration pipeline to execute arbitrary logic during a migration out of this release
     * @param _vaultProxy The VaultProxy being migrated
     */
    invokeMigrationOutHook(
      _hook: PromiseOrValue<BigNumberish>,
      _vaultProxy: PromiseOrValue<string>,
      arg2: PromiseOrValue<string>,
      arg3: PromiseOrValue<string>,
      arg4: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if a contract call is registered
     * @param _contract The contract of the call to check
     * @param _selector The selector of the call to check
     */
    isRegisteredVaultCall(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Registers allowed arbitrary contract calls that can be sent from the VaultProxy
     * @param _contracts The contracts of the calls to register
     * @param _selectors The selectors of the calls to register
     */
    registerVaultCalls(
      _contracts: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Can only be set once
     * Sets the comptrollerLib
     * @param _comptrollerLib The ComptrollerLib contract address
     */
    setComptrollerLib(
      _comptrollerLib: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the status of the protocol to a new state
     * @param _nextStatus The next status state to set
     */
    setReleaseStatus(
      _nextStatus: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Signal a fund migration
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigration(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Signal a fund migration, bypassing any failures. Should be used in an emergency only.
     * @param _comptrollerProxy The ComptrollerProxy for which to signal the migration
     * @param _vaultProxy The VaultProxy for which to signal the migration
     */
    signalMigrationEmergency(
      _vaultProxy: PromiseOrValue<string>,
      _comptrollerProxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}
