/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface IdleAdapterInterface extends utils.Interface {
  functions: {
    'ADD_TRACKED_ASSETS_SELECTOR()': FunctionFragment;
    'APPROVE_ASSETS_SELECTOR()': FunctionFragment;
    'CLAIM_REWARDS_AND_REINVEST_SELECTOR()': FunctionFragment;
    'CLAIM_REWARDS_AND_SWAP_SELECTOR()': FunctionFragment;
    'CLAIM_REWARDS_SELECTOR()': FunctionFragment;
    'LEND_AND_STAKE_SELECTOR()': FunctionFragment;
    'LEND_SELECTOR()': FunctionFragment;
    'REDEEM_SELECTOR()': FunctionFragment;
    'REMOVE_TRACKED_ASSETS_SELECTOR()': FunctionFragment;
    'STAKE_SELECTOR()': FunctionFragment;
    'TAKE_ORDER_SELECTOR()': FunctionFragment;
    'UNSTAKE_AND_REDEEM_SELECTOR()': FunctionFragment;
    'UNSTAKE_SELECTOR()': FunctionFragment;
    'approveAssets(address,bytes,bytes)': FunctionFragment;
    'claimRewards(address,bytes,bytes)': FunctionFragment;
    'claimRewardsAndReinvest(address,bytes,bytes)': FunctionFragment;
    'claimRewardsAndSwap(address,bytes,bytes)': FunctionFragment;
    'getIdlePriceFeed()': FunctionFragment;
    'getIntegrationManager()': FunctionFragment;
    'getUniswapV2Router2()': FunctionFragment;
    'getWethToken()': FunctionFragment;
    'identifier()': FunctionFragment;
    'lend(address,bytes,bytes)': FunctionFragment;
    'parseAssetsForMethod(bytes4,bytes)': FunctionFragment;
    'redeem(address,bytes,bytes)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'ADD_TRACKED_ASSETS_SELECTOR'
      | 'APPROVE_ASSETS_SELECTOR'
      | 'CLAIM_REWARDS_AND_REINVEST_SELECTOR'
      | 'CLAIM_REWARDS_AND_SWAP_SELECTOR'
      | 'CLAIM_REWARDS_SELECTOR'
      | 'LEND_AND_STAKE_SELECTOR'
      | 'LEND_SELECTOR'
      | 'REDEEM_SELECTOR'
      | 'REMOVE_TRACKED_ASSETS_SELECTOR'
      | 'STAKE_SELECTOR'
      | 'TAKE_ORDER_SELECTOR'
      | 'UNSTAKE_AND_REDEEM_SELECTOR'
      | 'UNSTAKE_SELECTOR'
      | 'approveAssets'
      | 'claimRewards'
      | 'claimRewardsAndReinvest'
      | 'claimRewardsAndSwap'
      | 'getIdlePriceFeed'
      | 'getIntegrationManager'
      | 'getUniswapV2Router2'
      | 'getWethToken'
      | 'identifier'
      | 'lend'
      | 'parseAssetsForMethod'
      | 'redeem',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'ADD_TRACKED_ASSETS_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'APPROVE_ASSETS_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'CLAIM_REWARDS_AND_REINVEST_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'CLAIM_REWARDS_AND_SWAP_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'CLAIM_REWARDS_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'LEND_AND_STAKE_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'LEND_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'REDEEM_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'REMOVE_TRACKED_ASSETS_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'STAKE_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'TAKE_ORDER_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'UNSTAKE_AND_REDEEM_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'UNSTAKE_SELECTOR',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'approveAssets',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'claimRewards',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'claimRewardsAndReinvest',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'claimRewardsAndSwap',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getIdlePriceFeed',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getIntegrationManager',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getUniswapV2Router2',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getWethToken',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'identifier',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'lend',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'parseAssetsForMethod',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'redeem',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;

  decodeFunctionResult(
    functionFragment: 'ADD_TRACKED_ASSETS_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'APPROVE_ASSETS_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'CLAIM_REWARDS_AND_REINVEST_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'CLAIM_REWARDS_AND_SWAP_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'CLAIM_REWARDS_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'LEND_AND_STAKE_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'LEND_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'REDEEM_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'REMOVE_TRACKED_ASSETS_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'STAKE_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'TAKE_ORDER_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'UNSTAKE_AND_REDEEM_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'UNSTAKE_SELECTOR',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'approveAssets',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'claimRewards',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'claimRewardsAndReinvest',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'claimRewardsAndSwap',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getIdlePriceFeed',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getIntegrationManager',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getUniswapV2Router2',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getWethToken',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'identifier', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lend', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'parseAssetsForMethod',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'redeem', data: BytesLike): Result;

  events: {};
}

export interface IdleAdapter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IdleAdapterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>,
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ADD_TRACKED_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    APPROVE_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    CLAIM_REWARDS_AND_REINVEST_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<[string]>;

    CLAIM_REWARDS_AND_SWAP_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<[string]>;

    CLAIM_REWARDS_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    LEND_AND_STAKE_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    LEND_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    REDEEM_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    REMOVE_TRACKED_ASSETS_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<[string]>;

    STAKE_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    TAKE_ORDER_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    UNSTAKE_AND_REDEEM_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    UNSTAKE_SELECTOR(overrides?: CallOverrides): Promise<[string]>;

    /**
     * No logic necessary. Exists only to grant adapter with necessary approvals from the vault, which takes place in the IntegrationManager.
     * Approves assets from the vault to be used by this contract.
     */
    approveAssets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      arg2: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Claims rewards for a givenIdleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewards(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then compounds the rewards tokens back into the idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndReinvest(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndSwap(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Gets the `IDLE_PRICE_FEED` variable
     */
    getIdlePriceFeed(
      overrides?: CallOverrides,
    ): Promise<[string] & { idlePriceFeed_: string }>;

    /**
     * Gets the `INTEGRATION_MANAGER` variable
     */
    getIntegrationManager(
      overrides?: CallOverrides,
    ): Promise<[string] & { integrationManager_: string }>;

    /**
     * Gets the `UNISWAP_V2_ROUTER2` variable
     */
    getUniswapV2Router2(
      overrides?: CallOverrides,
    ): Promise<[string] & { router_: string }>;

    /**
     * Gets the `WETH_TOKEN` variable
     */
    getWethToken(
      overrides?: CallOverrides,
    ): Promise<[string] & { wethToken_: string }>;

    /**
     * Provides a constant string identifier for an adapter
     */
    identifier(
      overrides?: CallOverrides,
    ): Promise<[string] & { identifier_: string }>;

    /**
     * Lends an amount of a token for idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    lend(
      _vaultProxy: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Parses the expected assets to receive from a call on integration
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _selector The function selector for the callOnIntegration
     */
    parseAssetsForMethod(
      _selector: PromiseOrValue<BytesLike>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<
      [number, string[], BigNumber[], string[], BigNumber[]] & {
        spendAssetsHandleType_: number;
        spendAssets_: string[];
        spendAssetAmounts_: BigNumber[];
        incomingAssets_: string[];
        minIncomingAssetAmounts_: BigNumber[];
      }
    >;

    /**
     * This will also pay out any due gov token rewards. We use the full IdleToken balance of the current contract rather than the user input for the corner case of a prior balance existing in the current contract, which would throw off the per-user avg price of the IdleToken used by Idle, and would leave the initial token balance in the current contract post-tx.
     * Redeems an amount of idleToken for its underlying asset
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    redeem(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  ADD_TRACKED_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<string>;

  APPROVE_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<string>;

  CLAIM_REWARDS_AND_REINVEST_SELECTOR(
    overrides?: CallOverrides,
  ): Promise<string>;

  CLAIM_REWARDS_AND_SWAP_SELECTOR(overrides?: CallOverrides): Promise<string>;

  CLAIM_REWARDS_SELECTOR(overrides?: CallOverrides): Promise<string>;

  LEND_AND_STAKE_SELECTOR(overrides?: CallOverrides): Promise<string>;

  LEND_SELECTOR(overrides?: CallOverrides): Promise<string>;

  REDEEM_SELECTOR(overrides?: CallOverrides): Promise<string>;

  REMOVE_TRACKED_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<string>;

  STAKE_SELECTOR(overrides?: CallOverrides): Promise<string>;

  TAKE_ORDER_SELECTOR(overrides?: CallOverrides): Promise<string>;

  UNSTAKE_AND_REDEEM_SELECTOR(overrides?: CallOverrides): Promise<string>;

  UNSTAKE_SELECTOR(overrides?: CallOverrides): Promise<string>;

  /**
   * No logic necessary. Exists only to grant adapter with necessary approvals from the vault, which takes place in the IntegrationManager.
   * Approves assets from the vault to be used by this contract.
   */
  approveAssets(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BytesLike>,
    arg2: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Claims rewards for a givenIdleToken
   * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
   * @param _encodedCallArgs The encoded parameters for the callOnIntegration
   * @param _vaultProxy The VaultProxy of the calling fund
   */
  claimRewards(
    _vaultProxy: PromiseOrValue<string>,
    _encodedCallArgs: PromiseOrValue<BytesLike>,
    _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
   * Claims rewards and then compounds the rewards tokens back into the idleToken
   * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
   * @param _encodedCallArgs Encoded order parameters
   * @param _vaultProxy The VaultProxy of the calling fund
   */
  claimRewardsAndReinvest(
    _vaultProxy: PromiseOrValue<string>,
    _encodedCallArgs: PromiseOrValue<BytesLike>,
    _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
   * Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2
   * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
   * @param _encodedCallArgs Encoded order parameters
   * @param _vaultProxy The VaultProxy of the calling fund
   */
  claimRewardsAndSwap(
    _vaultProxy: PromiseOrValue<string>,
    _encodedCallArgs: PromiseOrValue<BytesLike>,
    _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Gets the `IDLE_PRICE_FEED` variable
   */
  getIdlePriceFeed(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `INTEGRATION_MANAGER` variable
   */
  getIntegrationManager(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `UNISWAP_V2_ROUTER2` variable
   */
  getUniswapV2Router2(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `WETH_TOKEN` variable
   */
  getWethToken(overrides?: CallOverrides): Promise<string>;

  /**
   * Provides a constant string identifier for an adapter
   */
  identifier(overrides?: CallOverrides): Promise<string>;

  /**
   * Lends an amount of a token for idleToken
   * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
   * @param _vaultProxy The VaultProxy of the calling fund
   */
  lend(
    _vaultProxy: PromiseOrValue<string>,
    arg1: PromiseOrValue<BytesLike>,
    _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Parses the expected assets to receive from a call on integration
   * @param _encodedCallArgs The encoded parameters for the callOnIntegration
   * @param _selector The function selector for the callOnIntegration
   */
  parseAssetsForMethod(
    _selector: PromiseOrValue<BytesLike>,
    _encodedCallArgs: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<
    [number, string[], BigNumber[], string[], BigNumber[]] & {
      spendAssetsHandleType_: number;
      spendAssets_: string[];
      spendAssetAmounts_: BigNumber[];
      incomingAssets_: string[];
      minIncomingAssetAmounts_: BigNumber[];
    }
  >;

  /**
   * This will also pay out any due gov token rewards. We use the full IdleToken balance of the current contract rather than the user input for the corner case of a prior balance existing in the current contract, which would throw off the per-user avg price of the IdleToken used by Idle, and would leave the initial token balance in the current contract post-tx.
   * Redeems an amount of idleToken for its underlying asset
   * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
   * @param _encodedCallArgs The encoded parameters for the callOnIntegration
   * @param _vaultProxy The VaultProxy of the calling fund
   */
  redeem(
    _vaultProxy: PromiseOrValue<string>,
    _encodedCallArgs: PromiseOrValue<BytesLike>,
    _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    ADD_TRACKED_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<string>;

    APPROVE_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<string>;

    CLAIM_REWARDS_AND_REINVEST_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<string>;

    CLAIM_REWARDS_AND_SWAP_SELECTOR(overrides?: CallOverrides): Promise<string>;

    CLAIM_REWARDS_SELECTOR(overrides?: CallOverrides): Promise<string>;

    LEND_AND_STAKE_SELECTOR(overrides?: CallOverrides): Promise<string>;

    LEND_SELECTOR(overrides?: CallOverrides): Promise<string>;

    REDEEM_SELECTOR(overrides?: CallOverrides): Promise<string>;

    REMOVE_TRACKED_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<string>;

    STAKE_SELECTOR(overrides?: CallOverrides): Promise<string>;

    TAKE_ORDER_SELECTOR(overrides?: CallOverrides): Promise<string>;

    UNSTAKE_AND_REDEEM_SELECTOR(overrides?: CallOverrides): Promise<string>;

    UNSTAKE_SELECTOR(overrides?: CallOverrides): Promise<string>;

    /**
     * No logic necessary. Exists only to grant adapter with necessary approvals from the vault, which takes place in the IntegrationManager.
     * Approves assets from the vault to be used by this contract.
     */
    approveAssets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      arg2: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Claims rewards for a givenIdleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewards(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then compounds the rewards tokens back into the idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndReinvest(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndSwap(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Gets the `IDLE_PRICE_FEED` variable
     */
    getIdlePriceFeed(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `INTEGRATION_MANAGER` variable
     */
    getIntegrationManager(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `UNISWAP_V2_ROUTER2` variable
     */
    getUniswapV2Router2(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `WETH_TOKEN` variable
     */
    getWethToken(overrides?: CallOverrides): Promise<string>;

    /**
     * Provides a constant string identifier for an adapter
     */
    identifier(overrides?: CallOverrides): Promise<string>;

    /**
     * Lends an amount of a token for idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    lend(
      _vaultProxy: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Parses the expected assets to receive from a call on integration
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _selector The function selector for the callOnIntegration
     */
    parseAssetsForMethod(
      _selector: PromiseOrValue<BytesLike>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<
      [number, string[], BigNumber[], string[], BigNumber[]] & {
        spendAssetsHandleType_: number;
        spendAssets_: string[];
        spendAssetAmounts_: BigNumber[];
        incomingAssets_: string[];
        minIncomingAssetAmounts_: BigNumber[];
      }
    >;

    /**
     * This will also pay out any due gov token rewards. We use the full IdleToken balance of the current contract rather than the user input for the corner case of a prior balance existing in the current contract, which would throw off the per-user avg price of the IdleToken used by Idle, and would leave the initial token balance in the current contract post-tx.
     * Redeems an amount of idleToken for its underlying asset
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    redeem(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {};

  estimateGas: {
    ADD_TRACKED_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    APPROVE_ASSETS_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    CLAIM_REWARDS_AND_REINVEST_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    CLAIM_REWARDS_AND_SWAP_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    CLAIM_REWARDS_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    LEND_AND_STAKE_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    LEND_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    REDEEM_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    REMOVE_TRACKED_ASSETS_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    STAKE_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    TAKE_ORDER_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    UNSTAKE_AND_REDEEM_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    UNSTAKE_SELECTOR(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * No logic necessary. Exists only to grant adapter with necessary approvals from the vault, which takes place in the IntegrationManager.
     * Approves assets from the vault to be used by this contract.
     */
    approveAssets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      arg2: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Claims rewards for a givenIdleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewards(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then compounds the rewards tokens back into the idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndReinvest(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndSwap(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Gets the `IDLE_PRICE_FEED` variable
     */
    getIdlePriceFeed(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `INTEGRATION_MANAGER` variable
     */
    getIntegrationManager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `UNISWAP_V2_ROUTER2` variable
     */
    getUniswapV2Router2(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `WETH_TOKEN` variable
     */
    getWethToken(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Provides a constant string identifier for an adapter
     */
    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Lends an amount of a token for idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    lend(
      _vaultProxy: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Parses the expected assets to receive from a call on integration
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _selector The function selector for the callOnIntegration
     */
    parseAssetsForMethod(
      _selector: PromiseOrValue<BytesLike>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * This will also pay out any due gov token rewards. We use the full IdleToken balance of the current contract rather than the user input for the corner case of a prior balance existing in the current contract, which would throw off the per-user avg price of the IdleToken used by Idle, and would leave the initial token balance in the current contract post-tx.
     * Redeems an amount of idleToken for its underlying asset
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    redeem(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ADD_TRACKED_ASSETS_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    APPROVE_ASSETS_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    CLAIM_REWARDS_AND_REINVEST_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    CLAIM_REWARDS_AND_SWAP_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    CLAIM_REWARDS_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    LEND_AND_STAKE_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    LEND_SELECTOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REDEEM_SELECTOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REMOVE_TRACKED_ASSETS_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    STAKE_SELECTOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TAKE_ORDER_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    UNSTAKE_AND_REDEEM_SELECTOR(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    UNSTAKE_SELECTOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * No logic necessary. Exists only to grant adapter with necessary approvals from the vault, which takes place in the IntegrationManager.
     * Approves assets from the vault to be used by this contract.
     */
    approveAssets(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      arg2: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Claims rewards for a givenIdleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewards(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then compounds the rewards tokens back into the idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndReinvest(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * The `useFullBalances` option indicates whether to use only the newly claimed balances of rewards tokens, or whether to use the full balances of these assets in the vault. If full asset balances are to be used, then this requires the adapter to be granted an allowance of each reward token by the vault. For supported assets (e.g., COMP), this must be done via the `approveAssets()` function in this adapter. For unsupported assets (e.g., IDLE), this must be done via `ComptrollerProxy.vaultCallOnContract()`, if allowed.
     * Claims rewards and then swaps the rewards tokens to the specified asset via UniswapV2
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs Encoded order parameters
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    claimRewardsAndSwap(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `IDLE_PRICE_FEED` variable
     */
    getIdlePriceFeed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the `INTEGRATION_MANAGER` variable
     */
    getIntegrationManager(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `UNISWAP_V2_ROUTER2` variable
     */
    getUniswapV2Router2(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `WETH_TOKEN` variable
     */
    getWethToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Provides a constant string identifier for an adapter
     */
    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Lends an amount of a token for idleToken
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    lend(
      _vaultProxy: PromiseOrValue<string>,
      arg1: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Parses the expected assets to receive from a call on integration
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _selector The function selector for the callOnIntegration
     */
    parseAssetsForMethod(
      _selector: PromiseOrValue<BytesLike>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * This will also pay out any due gov token rewards. We use the full IdleToken balance of the current contract rather than the user input for the corner case of a prior balance existing in the current contract, which would throw off the per-user avg price of the IdleToken used by Idle, and would leave the initial token balance in the current contract post-tx.
     * Redeems an amount of idleToken for its underlying asset
     * @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive
     * @param _encodedCallArgs The encoded parameters for the callOnIntegration
     * @param _vaultProxy The VaultProxy of the calling fund
     */
    redeem(
      _vaultProxy: PromiseOrValue<string>,
      _encodedCallArgs: PromiseOrValue<BytesLike>,
      _encodedAssetTransferArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}
