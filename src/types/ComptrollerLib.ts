/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface ComptrollerLibInterface extends utils.Interface {
  functions: {
    'activate(address,bool)': FunctionFragment;
    'buyShares(address[],uint256[],uint256[])': FunctionFragment;
    'calcGav(bool)': FunctionFragment;
    'calcGrossShareValue(bool)': FunctionFragment;
    'callOnExtension(address,uint256,bytes)': FunctionFragment;
    'configureExtensions(bytes,bytes)': FunctionFragment;
    'destruct()': FunctionFragment;
    'getDenominationAsset()': FunctionFragment;
    'getLibRoutes()': FunctionFragment;
    'getOverridePause()': FunctionFragment;
    'getSharesActionTimelock()': FunctionFragment;
    'getSynthetixAddressResolver()': FunctionFragment;
    'getSynthetixPriceFeed()': FunctionFragment;
    'getVaultProxy()': FunctionFragment;
    'init(address,uint256)': FunctionFragment;
    'permissionedVaultAction(uint8,bytes)': FunctionFragment;
    'redeemShares()': FunctionFragment;
    'redeemSharesDetailed(uint256,address[],address[])': FunctionFragment;
    'setOverridePause(bool)': FunctionFragment;
    'vaultCallOnContract(address,bytes4,bytes)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'activate'
      | 'buyShares'
      | 'calcGav'
      | 'calcGrossShareValue'
      | 'callOnExtension'
      | 'configureExtensions'
      | 'destruct'
      | 'getDenominationAsset'
      | 'getLibRoutes'
      | 'getOverridePause'
      | 'getSharesActionTimelock'
      | 'getSynthetixAddressResolver'
      | 'getSynthetixPriceFeed'
      | 'getVaultProxy'
      | 'init'
      | 'permissionedVaultAction'
      | 'redeemShares'
      | 'redeemSharesDetailed'
      | 'setOverridePause'
      | 'vaultCallOnContract',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'activate',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'buyShares',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'calcGav',
    values: [PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'calcGrossShareValue',
    values: [PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'callOnExtension',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'configureExtensions',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'destruct', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getDenominationAsset',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getLibRoutes',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getOverridePause',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getSharesActionTimelock',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getSynthetixAddressResolver',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getSynthetixPriceFeed',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getVaultProxy',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'init',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'permissionedVaultAction',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'redeemShares',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'redeemSharesDetailed',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'setOverridePause',
    values: [PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'vaultCallOnContract',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;

  decodeFunctionResult(functionFragment: 'activate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'buyShares', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'calcGav', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'calcGrossShareValue',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'callOnExtension',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'configureExtensions',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'destruct', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getDenominationAsset',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getLibRoutes',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getOverridePause',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getSharesActionTimelock',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getSynthetixAddressResolver',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getSynthetixPriceFeed',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getVaultProxy',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'init', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'permissionedVaultAction',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'redeemShares',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'redeemSharesDetailed',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setOverridePause',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'vaultCallOnContract',
    data: BytesLike,
  ): Result;

  events: {
    'MigratedSharesDuePaid(uint256)': EventFragment;
    'OverridePauseSet(bool)': EventFragment;
    'PreRedeemSharesHookFailed(bytes,address,uint256)': EventFragment;
    'SharesBought(address,address,uint256,uint256,uint256)': EventFragment;
    'SharesRedeemed(address,uint256,address[],uint256[])': EventFragment;
    'VaultProxySet(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'MigratedSharesDuePaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OverridePauseSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'PreRedeemSharesHookFailed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SharesBought'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SharesRedeemed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'VaultProxySet'): EventFragment;
}

export interface MigratedSharesDuePaidEventObject {
  sharesDue: BigNumber;
}
export type MigratedSharesDuePaidEvent = TypedEvent<
  [BigNumber],
  MigratedSharesDuePaidEventObject
>;

export type MigratedSharesDuePaidEventFilter =
  TypedEventFilter<MigratedSharesDuePaidEvent>;

export interface OverridePauseSetEventObject {
  overridePause: boolean;
}
export type OverridePauseSetEvent = TypedEvent<
  [boolean],
  OverridePauseSetEventObject
>;

export type OverridePauseSetEventFilter =
  TypedEventFilter<OverridePauseSetEvent>;

export interface PreRedeemSharesHookFailedEventObject {
  failureReturnData: string;
  redeemer: string;
  sharesQuantity: BigNumber;
}
export type PreRedeemSharesHookFailedEvent = TypedEvent<
  [string, string, BigNumber],
  PreRedeemSharesHookFailedEventObject
>;

export type PreRedeemSharesHookFailedEventFilter =
  TypedEventFilter<PreRedeemSharesHookFailedEvent>;

export interface SharesBoughtEventObject {
  caller: string;
  buyer: string;
  investmentAmount: BigNumber;
  sharesIssued: BigNumber;
  sharesReceived: BigNumber;
}
export type SharesBoughtEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  SharesBoughtEventObject
>;

export type SharesBoughtEventFilter = TypedEventFilter<SharesBoughtEvent>;

export interface SharesRedeemedEventObject {
  redeemer: string;
  sharesQuantity: BigNumber;
  receivedAssets: string[];
  receivedAssetQuantities: BigNumber[];
}
export type SharesRedeemedEvent = TypedEvent<
  [string, BigNumber, string[], BigNumber[]],
  SharesRedeemedEventObject
>;

export type SharesRedeemedEventFilter = TypedEventFilter<SharesRedeemedEvent>;

export interface VaultProxySetEventObject {
  vaultProxy: string;
}
export type VaultProxySetEvent = TypedEvent<[string], VaultProxySetEventObject>;

export type VaultProxySetEventFilter = TypedEventFilter<VaultProxySetEvent>;

export interface ComptrollerLib extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ComptrollerLibInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>,
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * No need to assert anything beyond FundDeployer access.
     * Activates the fund by attaching a VaultProxy and activating all Extensions
     * @param _isMigration True if a migrated fund is being activated
     * @param _vaultProxy The VaultProxy to attach to the fund
     */
    activate(
      _vaultProxy: PromiseOrValue<string>,
      _isMigration: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Param arrays have indexes corresponding to individual __buyShares() orders.
     * Buys shares in the fund for multiple sets of criteria
     * @param _buyers The accounts for which to buy shares
     * @param _investmentAmounts The amounts of the fund's denomination asset with which to buy shares for the corresponding _buyers
     * @param _minSharesQuantities The minimum quantities of shares to buy with the corresponding _investmentAmounts
     */
    buyShares(
      _buyers: PromiseOrValue<string>[],
      _investmentAmounts: PromiseOrValue<BigNumberish>[],
      _minSharesQuantities: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Calculates the gross asset value (GAV) of the fund
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGav(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Does not account for any fees outstanding.
     * Calculates the gross value of 1 unit of shares in the fund's denomination asset
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGrossShareValue(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy (for access control). Uses a mutex of sorts that allows "permissioned vault actions" during calls originating from this function.
     * Calls a specified action on an Extension
     * @param _actionId An ID representing the action to take on the extension (see extension)
     * @param _callArgs The encoded data for the call
     * @param _extension The Extension contract to call (e.g., FeeManager)
     */
    callOnExtension(
      _extension: PromiseOrValue<string>,
      _actionId: PromiseOrValue<BigNumberish>,
      _callArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * No need to assert anything beyond FundDeployer access. Called atomically with init(), but after ComptrollerLib has been deployed, giving access to its state and interface
     * Configure the extensions of a fund
     * @param _feeManagerConfigData Encoded config for fees to enable
     * @param _policyManagerConfigData Encoded config for policies to enable
     */
    configureExtensions(
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * No need to assert anything beyond FundDeployer access. Calling onlyNotPaused here rather than in the FundDeployer allows the owner to potentially override the pause and rescue unpaid fees.
     * Remove the config for a fund
     */
    destruct(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Gets the `denominationAsset` variable
     */
    getDenominationAsset(
      overrides?: CallOverrides,
    ): Promise<[string] & { denominationAsset_: string }>;

    /**
     * Gets the routes for the various contracts used by all funds
     */
    getLibRoutes(overrides?: CallOverrides): Promise<
      [string, string, string, string, string, string, string] & {
        dispatcher_: string;
        feeManager_: string;
        fundDeployer_: string;
        integrationManager_: string;
        policyManager_: string;
        primitivePriceFeed_: string;
        valueInterpreter_: string;
      }
    >;

    /**
     * Gets the `overridePause` variable
     */
    getOverridePause(
      overrides?: CallOverrides,
    ): Promise<[boolean] & { overridePause_: boolean }>;

    /**
     * Gets the `sharesActionTimelock` variable
     */
    getSharesActionTimelock(
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { sharesActionTimelock_: BigNumber }>;

    /**
     * Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable
     */
    getSynthetixAddressResolver(
      overrides?: CallOverrides,
    ): Promise<[string] & { synthetixAddressResolver_: string }>;

    /**
     * Gets the `SYNTHETIX_PRICE_FEED` variable
     */
    getSynthetixPriceFeed(
      overrides?: CallOverrides,
    ): Promise<[string] & { synthetixPriceFeed_: string }>;

    /**
     * Gets the `vaultProxy` variable
     */
    getVaultProxy(
      overrides?: CallOverrides,
    ): Promise<[string] & { vaultProxy_: string }>;

    /**
     * Pseudo-constructor per proxy. No need to assert access because this is called atomically on deployment, and once it's called, it cannot be called again.
     * Initializes a fund with its core config
     * @param _denominationAsset The asset in which the fund's value should be denominated
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    init(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Makes a permissioned, state-changing call on the VaultProxy contract
     * @param _action The enum representing the VaultAction to perform on the VaultProxy
     * @param _actionData The call data for the action to perform
     */
    permissionedVaultAction(
      _action: PromiseOrValue<BigNumberish>,
      _actionData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * See __redeemShares() for further detail
     * Redeem all of the sender's shares for a proportionate slice of the fund's assets
     */
    redeemShares(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Any claim to passed _assetsToSkip will be forfeited entirely. This should generally only be exercised if a bad asset is causing redemption to fail.
     * Redeem a specified quantity of the sender's shares for a proportionate slice of the fund's assets, optionally specifying additional assets and assets to skip.
     * @param _additionalAssets Additional (non-tracked) assets to claim
     * @param _assetsToSkip Tracked assets to forfeit
     * @param _sharesQuantity The quantity of shares to redeem
     */
    redeemSharesDetailed(
      _sharesQuantity: PromiseOrValue<BigNumberish>,
      _additionalAssets: PromiseOrValue<string>[],
      _assetsToSkip: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Sets or unsets an override on a release-wide pause
     * @param _nextOverridePause True if the pause should be overrode
     */
    setOverridePause(
      _nextOverridePause: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    /**
     * Makes an arbitrary call with the VaultProxy contract as the sender
     * @param _contract The contract to call
     * @param _encodedArgs The encoded arguments for the call
     * @param _selector The selector to call
     */
    vaultCallOnContract(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      _encodedArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  /**
   * No need to assert anything beyond FundDeployer access.
   * Activates the fund by attaching a VaultProxy and activating all Extensions
   * @param _isMigration True if a migrated fund is being activated
   * @param _vaultProxy The VaultProxy to attach to the fund
   */
  activate(
    _vaultProxy: PromiseOrValue<string>,
    _isMigration: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Param arrays have indexes corresponding to individual __buyShares() orders.
   * Buys shares in the fund for multiple sets of criteria
   * @param _buyers The accounts for which to buy shares
   * @param _investmentAmounts The amounts of the fund's denomination asset with which to buy shares for the corresponding _buyers
   * @param _minSharesQuantities The minimum quantities of shares to buy with the corresponding _investmentAmounts
   */
  buyShares(
    _buyers: PromiseOrValue<string>[],
    _investmentAmounts: PromiseOrValue<BigNumberish>[],
    _minSharesQuantities: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Calculates the gross asset value (GAV) of the fund
   * @param _requireFinality True if all assets must have exact final balances settled
   */
  calcGav(
    _requireFinality: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Does not account for any fees outstanding.
   * Calculates the gross value of 1 unit of shares in the fund's denomination asset
   * @param _requireFinality True if all assets must have exact final balances settled
   */
  calcGrossShareValue(
    _requireFinality: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy (for access control). Uses a mutex of sorts that allows "permissioned vault actions" during calls originating from this function.
   * Calls a specified action on an Extension
   * @param _actionId An ID representing the action to take on the extension (see extension)
   * @param _callArgs The encoded data for the call
   * @param _extension The Extension contract to call (e.g., FeeManager)
   */
  callOnExtension(
    _extension: PromiseOrValue<string>,
    _actionId: PromiseOrValue<BigNumberish>,
    _callArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * No need to assert anything beyond FundDeployer access. Called atomically with init(), but after ComptrollerLib has been deployed, giving access to its state and interface
   * Configure the extensions of a fund
   * @param _feeManagerConfigData Encoded config for fees to enable
   * @param _policyManagerConfigData Encoded config for policies to enable
   */
  configureExtensions(
    _feeManagerConfigData: PromiseOrValue<BytesLike>,
    _policyManagerConfigData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * No need to assert anything beyond FundDeployer access. Calling onlyNotPaused here rather than in the FundDeployer allows the owner to potentially override the pause and rescue unpaid fees.
   * Remove the config for a fund
   */
  destruct(
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Gets the `denominationAsset` variable
   */
  getDenominationAsset(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the routes for the various contracts used by all funds
   */
  getLibRoutes(overrides?: CallOverrides): Promise<
    [string, string, string, string, string, string, string] & {
      dispatcher_: string;
      feeManager_: string;
      fundDeployer_: string;
      integrationManager_: string;
      policyManager_: string;
      primitivePriceFeed_: string;
      valueInterpreter_: string;
    }
  >;

  /**
   * Gets the `overridePause` variable
   */
  getOverridePause(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Gets the `sharesActionTimelock` variable
   */
  getSharesActionTimelock(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable
   */
  getSynthetixAddressResolver(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `SYNTHETIX_PRICE_FEED` variable
   */
  getSynthetixPriceFeed(overrides?: CallOverrides): Promise<string>;

  /**
   * Gets the `vaultProxy` variable
   */
  getVaultProxy(overrides?: CallOverrides): Promise<string>;

  /**
   * Pseudo-constructor per proxy. No need to assert access because this is called atomically on deployment, and once it's called, it cannot be called again.
   * Initializes a fund with its core config
   * @param _denominationAsset The asset in which the fund's value should be denominated
   * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
   */
  init(
    _denominationAsset: PromiseOrValue<string>,
    _sharesActionTimelock: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Makes a permissioned, state-changing call on the VaultProxy contract
   * @param _action The enum representing the VaultAction to perform on the VaultProxy
   * @param _actionData The call data for the action to perform
   */
  permissionedVaultAction(
    _action: PromiseOrValue<BigNumberish>,
    _actionData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * See __redeemShares() for further detail
   * Redeem all of the sender's shares for a proportionate slice of the fund's assets
   */
  redeemShares(
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Any claim to passed _assetsToSkip will be forfeited entirely. This should generally only be exercised if a bad asset is causing redemption to fail.
   * Redeem a specified quantity of the sender's shares for a proportionate slice of the fund's assets, optionally specifying additional assets and assets to skip.
   * @param _additionalAssets Additional (non-tracked) assets to claim
   * @param _assetsToSkip Tracked assets to forfeit
   * @param _sharesQuantity The quantity of shares to redeem
   */
  redeemSharesDetailed(
    _sharesQuantity: PromiseOrValue<BigNumberish>,
    _additionalAssets: PromiseOrValue<string>[],
    _assetsToSkip: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Sets or unsets an override on a release-wide pause
   * @param _nextOverridePause True if the pause should be overrode
   */
  setOverridePause(
    _nextOverridePause: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  /**
   * Makes an arbitrary call with the VaultProxy contract as the sender
   * @param _contract The contract to call
   * @param _encodedArgs The encoded arguments for the call
   * @param _selector The selector to call
   */
  vaultCallOnContract(
    _contract: PromiseOrValue<string>,
    _selector: PromiseOrValue<BytesLike>,
    _encodedArgs: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * No need to assert anything beyond FundDeployer access.
     * Activates the fund by attaching a VaultProxy and activating all Extensions
     * @param _isMigration True if a migrated fund is being activated
     * @param _vaultProxy The VaultProxy to attach to the fund
     */
    activate(
      _vaultProxy: PromiseOrValue<string>,
      _isMigration: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Param arrays have indexes corresponding to individual __buyShares() orders.
     * Buys shares in the fund for multiple sets of criteria
     * @param _buyers The accounts for which to buy shares
     * @param _investmentAmounts The amounts of the fund's denomination asset with which to buy shares for the corresponding _buyers
     * @param _minSharesQuantities The minimum quantities of shares to buy with the corresponding _investmentAmounts
     */
    buyShares(
      _buyers: PromiseOrValue<string>[],
      _investmentAmounts: PromiseOrValue<BigNumberish>[],
      _minSharesQuantities: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    /**
     * Calculates the gross asset value (GAV) of the fund
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGav(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, boolean] & { gav_: BigNumber; isValid_: boolean }>;

    /**
     * Does not account for any fees outstanding.
     * Calculates the gross value of 1 unit of shares in the fund's denomination asset
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGrossShareValue(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, boolean] & { grossShareValue_: BigNumber; isValid_: boolean }
    >;

    /**
     * Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy (for access control). Uses a mutex of sorts that allows "permissioned vault actions" during calls originating from this function.
     * Calls a specified action on an Extension
     * @param _actionId An ID representing the action to take on the extension (see extension)
     * @param _callArgs The encoded data for the call
     * @param _extension The Extension contract to call (e.g., FeeManager)
     */
    callOnExtension(
      _extension: PromiseOrValue<string>,
      _actionId: PromiseOrValue<BigNumberish>,
      _callArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * No need to assert anything beyond FundDeployer access. Called atomically with init(), but after ComptrollerLib has been deployed, giving access to its state and interface
     * Configure the extensions of a fund
     * @param _feeManagerConfigData Encoded config for fees to enable
     * @param _policyManagerConfigData Encoded config for policies to enable
     */
    configureExtensions(
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * No need to assert anything beyond FundDeployer access. Calling onlyNotPaused here rather than in the FundDeployer allows the owner to potentially override the pause and rescue unpaid fees.
     * Remove the config for a fund
     */
    destruct(overrides?: CallOverrides): Promise<void>;

    /**
     * Gets the `denominationAsset` variable
     */
    getDenominationAsset(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the routes for the various contracts used by all funds
     */
    getLibRoutes(overrides?: CallOverrides): Promise<
      [string, string, string, string, string, string, string] & {
        dispatcher_: string;
        feeManager_: string;
        fundDeployer_: string;
        integrationManager_: string;
        policyManager_: string;
        primitivePriceFeed_: string;
        valueInterpreter_: string;
      }
    >;

    /**
     * Gets the `overridePause` variable
     */
    getOverridePause(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Gets the `sharesActionTimelock` variable
     */
    getSharesActionTimelock(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable
     */
    getSynthetixAddressResolver(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `SYNTHETIX_PRICE_FEED` variable
     */
    getSynthetixPriceFeed(overrides?: CallOverrides): Promise<string>;

    /**
     * Gets the `vaultProxy` variable
     */
    getVaultProxy(overrides?: CallOverrides): Promise<string>;

    /**
     * Pseudo-constructor per proxy. No need to assert access because this is called atomically on deployment, and once it's called, it cannot be called again.
     * Initializes a fund with its core config
     * @param _denominationAsset The asset in which the fund's value should be denominated
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    init(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Makes a permissioned, state-changing call on the VaultProxy contract
     * @param _action The enum representing the VaultAction to perform on the VaultProxy
     * @param _actionData The call data for the action to perform
     */
    permissionedVaultAction(
      _action: PromiseOrValue<BigNumberish>,
      _actionData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * See __redeemShares() for further detail
     * Redeem all of the sender's shares for a proportionate slice of the fund's assets
     */
    redeemShares(overrides?: CallOverrides): Promise<
      [string[], BigNumber[]] & {
        payoutAssets_: string[];
        payoutAmounts_: BigNumber[];
      }
    >;

    /**
     * Any claim to passed _assetsToSkip will be forfeited entirely. This should generally only be exercised if a bad asset is causing redemption to fail.
     * Redeem a specified quantity of the sender's shares for a proportionate slice of the fund's assets, optionally specifying additional assets and assets to skip.
     * @param _additionalAssets Additional (non-tracked) assets to claim
     * @param _assetsToSkip Tracked assets to forfeit
     * @param _sharesQuantity The quantity of shares to redeem
     */
    redeemSharesDetailed(
      _sharesQuantity: PromiseOrValue<BigNumberish>,
      _additionalAssets: PromiseOrValue<string>[],
      _assetsToSkip: PromiseOrValue<string>[],
      overrides?: CallOverrides,
    ): Promise<
      [string[], BigNumber[]] & {
        payoutAssets_: string[];
        payoutAmounts_: BigNumber[];
      }
    >;

    /**
     * Sets or unsets an override on a release-wide pause
     * @param _nextOverridePause True if the pause should be overrode
     */
    setOverridePause(
      _nextOverridePause: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    /**
     * Makes an arbitrary call with the VaultProxy contract as the sender
     * @param _contract The contract to call
     * @param _encodedArgs The encoded arguments for the call
     * @param _selector The selector to call
     */
    vaultCallOnContract(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      _encodedArgs: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'MigratedSharesDuePaid(uint256)'(
      sharesDue?: null,
    ): MigratedSharesDuePaidEventFilter;
    MigratedSharesDuePaid(sharesDue?: null): MigratedSharesDuePaidEventFilter;

    'OverridePauseSet(bool)'(
      overridePause?: PromiseOrValue<boolean> | null,
    ): OverridePauseSetEventFilter;
    OverridePauseSet(
      overridePause?: PromiseOrValue<boolean> | null,
    ): OverridePauseSetEventFilter;

    'PreRedeemSharesHookFailed(bytes,address,uint256)'(
      failureReturnData?: null,
      redeemer?: null,
      sharesQuantity?: null,
    ): PreRedeemSharesHookFailedEventFilter;
    PreRedeemSharesHookFailed(
      failureReturnData?: null,
      redeemer?: null,
      sharesQuantity?: null,
    ): PreRedeemSharesHookFailedEventFilter;

    'SharesBought(address,address,uint256,uint256,uint256)'(
      caller?: PromiseOrValue<string> | null,
      buyer?: PromiseOrValue<string> | null,
      investmentAmount?: null,
      sharesIssued?: null,
      sharesReceived?: null,
    ): SharesBoughtEventFilter;
    SharesBought(
      caller?: PromiseOrValue<string> | null,
      buyer?: PromiseOrValue<string> | null,
      investmentAmount?: null,
      sharesIssued?: null,
      sharesReceived?: null,
    ): SharesBoughtEventFilter;

    'SharesRedeemed(address,uint256,address[],uint256[])'(
      redeemer?: PromiseOrValue<string> | null,
      sharesQuantity?: null,
      receivedAssets?: null,
      receivedAssetQuantities?: null,
    ): SharesRedeemedEventFilter;
    SharesRedeemed(
      redeemer?: PromiseOrValue<string> | null,
      sharesQuantity?: null,
      receivedAssets?: null,
      receivedAssetQuantities?: null,
    ): SharesRedeemedEventFilter;

    'VaultProxySet(address)'(vaultProxy?: null): VaultProxySetEventFilter;
    VaultProxySet(vaultProxy?: null): VaultProxySetEventFilter;
  };

  estimateGas: {
    /**
     * No need to assert anything beyond FundDeployer access.
     * Activates the fund by attaching a VaultProxy and activating all Extensions
     * @param _isMigration True if a migrated fund is being activated
     * @param _vaultProxy The VaultProxy to attach to the fund
     */
    activate(
      _vaultProxy: PromiseOrValue<string>,
      _isMigration: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Param arrays have indexes corresponding to individual __buyShares() orders.
     * Buys shares in the fund for multiple sets of criteria
     * @param _buyers The accounts for which to buy shares
     * @param _investmentAmounts The amounts of the fund's denomination asset with which to buy shares for the corresponding _buyers
     * @param _minSharesQuantities The minimum quantities of shares to buy with the corresponding _investmentAmounts
     */
    buyShares(
      _buyers: PromiseOrValue<string>[],
      _investmentAmounts: PromiseOrValue<BigNumberish>[],
      _minSharesQuantities: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Calculates the gross asset value (GAV) of the fund
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGav(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Does not account for any fees outstanding.
     * Calculates the gross value of 1 unit of shares in the fund's denomination asset
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGrossShareValue(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy (for access control). Uses a mutex of sorts that allows "permissioned vault actions" during calls originating from this function.
     * Calls a specified action on an Extension
     * @param _actionId An ID representing the action to take on the extension (see extension)
     * @param _callArgs The encoded data for the call
     * @param _extension The Extension contract to call (e.g., FeeManager)
     */
    callOnExtension(
      _extension: PromiseOrValue<string>,
      _actionId: PromiseOrValue<BigNumberish>,
      _callArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * No need to assert anything beyond FundDeployer access. Called atomically with init(), but after ComptrollerLib has been deployed, giving access to its state and interface
     * Configure the extensions of a fund
     * @param _feeManagerConfigData Encoded config for fees to enable
     * @param _policyManagerConfigData Encoded config for policies to enable
     */
    configureExtensions(
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * No need to assert anything beyond FundDeployer access. Calling onlyNotPaused here rather than in the FundDeployer allows the owner to potentially override the pause and rescue unpaid fees.
     * Remove the config for a fund
     */
    destruct(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Gets the `denominationAsset` variable
     */
    getDenominationAsset(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the routes for the various contracts used by all funds
     */
    getLibRoutes(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `overridePause` variable
     */
    getOverridePause(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `sharesActionTimelock` variable
     */
    getSharesActionTimelock(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable
     */
    getSynthetixAddressResolver(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `SYNTHETIX_PRICE_FEED` variable
     */
    getSynthetixPriceFeed(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets the `vaultProxy` variable
     */
    getVaultProxy(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Pseudo-constructor per proxy. No need to assert access because this is called atomically on deployment, and once it's called, it cannot be called again.
     * Initializes a fund with its core config
     * @param _denominationAsset The asset in which the fund's value should be denominated
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    init(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Makes a permissioned, state-changing call on the VaultProxy contract
     * @param _action The enum representing the VaultAction to perform on the VaultProxy
     * @param _actionData The call data for the action to perform
     */
    permissionedVaultAction(
      _action: PromiseOrValue<BigNumberish>,
      _actionData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * See __redeemShares() for further detail
     * Redeem all of the sender's shares for a proportionate slice of the fund's assets
     */
    redeemShares(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Any claim to passed _assetsToSkip will be forfeited entirely. This should generally only be exercised if a bad asset is causing redemption to fail.
     * Redeem a specified quantity of the sender's shares for a proportionate slice of the fund's assets, optionally specifying additional assets and assets to skip.
     * @param _additionalAssets Additional (non-tracked) assets to claim
     * @param _assetsToSkip Tracked assets to forfeit
     * @param _sharesQuantity The quantity of shares to redeem
     */
    redeemSharesDetailed(
      _sharesQuantity: PromiseOrValue<BigNumberish>,
      _additionalAssets: PromiseOrValue<string>[],
      _assetsToSkip: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Sets or unsets an override on a release-wide pause
     * @param _nextOverridePause True if the pause should be overrode
     */
    setOverridePause(
      _nextOverridePause: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    /**
     * Makes an arbitrary call with the VaultProxy contract as the sender
     * @param _contract The contract to call
     * @param _encodedArgs The encoded arguments for the call
     * @param _selector The selector to call
     */
    vaultCallOnContract(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      _encodedArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * No need to assert anything beyond FundDeployer access.
     * Activates the fund by attaching a VaultProxy and activating all Extensions
     * @param _isMigration True if a migrated fund is being activated
     * @param _vaultProxy The VaultProxy to attach to the fund
     */
    activate(
      _vaultProxy: PromiseOrValue<string>,
      _isMigration: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Param arrays have indexes corresponding to individual __buyShares() orders.
     * Buys shares in the fund for multiple sets of criteria
     * @param _buyers The accounts for which to buy shares
     * @param _investmentAmounts The amounts of the fund's denomination asset with which to buy shares for the corresponding _buyers
     * @param _minSharesQuantities The minimum quantities of shares to buy with the corresponding _investmentAmounts
     */
    buyShares(
      _buyers: PromiseOrValue<string>[],
      _investmentAmounts: PromiseOrValue<BigNumberish>[],
      _minSharesQuantities: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Calculates the gross asset value (GAV) of the fund
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGav(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Does not account for any fees outstanding.
     * Calculates the gross value of 1 unit of shares in the fund's denomination asset
     * @param _requireFinality True if all assets must have exact final balances settled
     */
    calcGrossShareValue(
      _requireFinality: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy (for access control). Uses a mutex of sorts that allows "permissioned vault actions" during calls originating from this function.
     * Calls a specified action on an Extension
     * @param _actionId An ID representing the action to take on the extension (see extension)
     * @param _callArgs The encoded data for the call
     * @param _extension The Extension contract to call (e.g., FeeManager)
     */
    callOnExtension(
      _extension: PromiseOrValue<string>,
      _actionId: PromiseOrValue<BigNumberish>,
      _callArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * No need to assert anything beyond FundDeployer access. Called atomically with init(), but after ComptrollerLib has been deployed, giving access to its state and interface
     * Configure the extensions of a fund
     * @param _feeManagerConfigData Encoded config for fees to enable
     * @param _policyManagerConfigData Encoded config for policies to enable
     */
    configureExtensions(
      _feeManagerConfigData: PromiseOrValue<BytesLike>,
      _policyManagerConfigData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * No need to assert anything beyond FundDeployer access. Calling onlyNotPaused here rather than in the FundDeployer allows the owner to potentially override the pause and rescue unpaid fees.
     * Remove the config for a fund
     */
    destruct(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `denominationAsset` variable
     */
    getDenominationAsset(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the routes for the various contracts used by all funds
     */
    getLibRoutes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the `overridePause` variable
     */
    getOverridePause(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Gets the `sharesActionTimelock` variable
     */
    getSharesActionTimelock(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable
     */
    getSynthetixAddressResolver(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `SYNTHETIX_PRICE_FEED` variable
     */
    getSynthetixPriceFeed(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the `vaultProxy` variable
     */
    getVaultProxy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Pseudo-constructor per proxy. No need to assert access because this is called atomically on deployment, and once it's called, it cannot be called again.
     * Initializes a fund with its core config
     * @param _denominationAsset The asset in which the fund's value should be denominated
     * @param _sharesActionTimelock The minimum number of seconds between any two "shares actions" (buying or selling shares) by the same user
     */
    init(
      _denominationAsset: PromiseOrValue<string>,
      _sharesActionTimelock: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Makes a permissioned, state-changing call on the VaultProxy contract
     * @param _action The enum representing the VaultAction to perform on the VaultProxy
     * @param _actionData The call data for the action to perform
     */
    permissionedVaultAction(
      _action: PromiseOrValue<BigNumberish>,
      _actionData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * See __redeemShares() for further detail
     * Redeem all of the sender's shares for a proportionate slice of the fund's assets
     */
    redeemShares(
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Any claim to passed _assetsToSkip will be forfeited entirely. This should generally only be exercised if a bad asset is causing redemption to fail.
     * Redeem a specified quantity of the sender's shares for a proportionate slice of the fund's assets, optionally specifying additional assets and assets to skip.
     * @param _additionalAssets Additional (non-tracked) assets to claim
     * @param _assetsToSkip Tracked assets to forfeit
     * @param _sharesQuantity The quantity of shares to redeem
     */
    redeemSharesDetailed(
      _sharesQuantity: PromiseOrValue<BigNumberish>,
      _additionalAssets: PromiseOrValue<string>[],
      _assetsToSkip: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Sets or unsets an override on a release-wide pause
     * @param _nextOverridePause True if the pause should be overrode
     */
    setOverridePause(
      _nextOverridePause: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    /**
     * Makes an arbitrary call with the VaultProxy contract as the sender
     * @param _contract The contract to call
     * @param _encodedArgs The encoded arguments for the call
     * @param _selector The selector to call
     */
    vaultCallOnContract(
      _contract: PromiseOrValue<string>,
      _selector: PromiseOrValue<BytesLike>,
      _encodedArgs: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}
